<!DOCTYPE html>
<html>
<head>
<title>NEON RIVALS | ULTRA PRO</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap" rel="stylesheet">
<style>
body { margin:0; overflow:hidden; background:#000; font-family:'Orbitron',sans-serif; }
#hud { position:fixed; bottom:30px; left:30px; color:#00f2ff; text-shadow:0 0 15px #00f2ff; z-index:10;}
#score { font-size:18px; margin-top:8px;}
.weapon-info { font-size:24px; border-left:4px solid #ff00ff; padding-left:15px;}
#crosshair {
position:fixed; top:50%; left:50%;
width:16px; height:16px;
border:2px solid #fff;
border-radius:50%;
transform:translate(-50%,-50%);
}
</style>
</head>
<body>

<div id="hud">
<div class="weapon-info">
<div>PULSE RIFLE</div>
<div style="font-size:12px;color:#fff;">AMMO: âˆž</div>
<div id="score">SCORE: 0</div>
</div>
</div>
<div id="crosshair"></div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.Fog(0x020205, 20, 600);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.y = 2;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

// LIGHTING
const ambient = new THREE.AmbientLight(0x00f2ff,0.4);
scene.add(ambient);

const light = new THREE.PointLight(0xff00ff,2,200);
light.position.set(0,50,0);
scene.add(light);

// FLOOR
const floor = new THREE.Mesh(
new THREE.PlaneGeometry(1000,1000),
new THREE.MeshStandardMaterial({color:0x050505, roughness:0.2})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// BUILDINGS
for(let i=0;i<60;i++){
let h = 10 + Math.random()*60;
let b = new THREE.Mesh(
new THREE.BoxGeometry(10,h,10),
new THREE.MeshStandardMaterial({
color:0x111111,
emissive:0x00f2ff,
emissiveIntensity:0.15
})
);
b.position.set(Math.random()*500-250, h/2, Math.random()*500-250);
scene.add(b);
}

// ENEMIES
let enemies=[];
function spawnEnemy(){
let e = new THREE.Mesh(
new THREE.SphereGeometry(1.5,16,16),
new THREE.MeshStandardMaterial({color:0xff0044, emissive:0xff0044, emissiveIntensity:1})
);
e.position.set(
Math.random()*200-100,
2,
Math.random()*200-100
);
scene.add(e);
enemies.push(e);
}
for(let i=0;i<5;i++) spawnEnemy();

// GUN
const gun = new THREE.Group();
const body = new THREE.Mesh(
new THREE.BoxGeometry(0.4,0.6,1),
new THREE.MeshStandardMaterial({color:0x111111})
);
const glow = new THREE.Mesh(
new THREE.BoxGeometry(0.1,0.1,1.2),
new THREE.MeshStandardMaterial({color:0x00f2ff, emissive:0x00f2ff, emissiveIntensity:5})
);
glow.position.z=0.2;
gun.add(body,glow);
scene.add(gun);

// CONTROLS
let keys={}, velocity=new THREE.Vector3();
let canJump=true;
let score=0;
const raycaster = new THREE.Raycaster();

onkeydown=e=>keys[e.code]=true;
onkeyup=e=>keys[e.code]=false;

// Mouse look
document.body.onclick=()=>document.body.requestPointerLock();
document.addEventListener("mousemove",(e)=>{
if(document.pointerLockElement===document.body){
camera.rotation.y -= e.movementX*0.002;
camera.rotation.x -= e.movementY*0.002;
camera.rotation.x = Math.max(-1.5,Math.min(1.5,camera.rotation.x));
}
});

// Shooting
onmousedown=()=>{
glow.material.emissiveIntensity=20;
setTimeout(()=>glow.material.emissiveIntensity=5,50);

raycaster.setFromCamera(new THREE.Vector2(0,0),camera);
let hits=raycaster.intersectObjects(enemies);
if(hits.length>0){
scene.remove(hits[0].object);
enemies.splice(enemies.indexOf(hits[0].object),1);
spawnEnemy();
score+=10;
document.getElementById("score").innerText="SCORE: "+score;
}
};

// PHYSICS
let gravity=0.01;

function animate(){
requestAnimationFrame(animate);

// movement
let speed = keys["ShiftLeft"]?0.25:0.15;
if(keys["KeyW"]) camera.translateZ(-speed);
if(keys["KeyS"]) camera.translateZ(speed);
if(keys["KeyA"]) camera.translateX(-speed);
if(keys["KeyD"]) camera.translateX(speed);

// jump
if(keys["Space"] && canJump){
velocity.y=0.2;
canJump=false;
}
velocity.y -= gravity;
camera.position.y += velocity.y;
if(camera.position.y<=2){
camera.position.y=2;
velocity.y=0;
canJump=true;
}

// gun position
let offset=new THREE.Vector3(0.5,-0.5,-1.5);
offset.applyQuaternion(camera.quaternion);
gun.position.copy(camera.position).add(offset);
gun.quaternion.copy(camera.quaternion);

// enemy floating motion
enemies.forEach(e=>{
e.position.y = 2 + Math.sin(Date.now()*0.002)*0.5;
});

// recoil smooth return
gun.position.lerp(camera.position.clone().add(offset),0.1);

renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
