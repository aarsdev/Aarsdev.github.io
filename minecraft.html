<!DOCTYPE html>
<html>
<head>
    <title>NEONVERSE | BUILD & BATTLE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; }
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; color: #fff; padding: 20px; }
        .build-mode { color: #00f2ff; font-size: 20px; text-shadow: 0 0 10px #00f2ff; visibility: hidden; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 6px; height: 6px; background: #fff; border-radius: 50%; transform: translate(-50%, -50%); }
    </style>
</head>
<body>

<div id="ui">
    <div id="mode-indicator" class="build-mode">BUILD MODE: WALL [Q]</div>
    <div style="margin-top: 10px;">LEFT CLICK: PLACE | WASD: MOVE</div>
</div>
<div id="crosshair"></div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
import { getDatabase, ref, set, onValue, onChildAdded } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

// --- FIREBASE SETUP ---
const firebaseConfig = {
    apiKey: "AIzaSyD9I2tePOBy4OdbFjbAzxAPvvziqvoe0QI",
    authDomain: "neonverse-aars.firebaseapp.com",
    projectId: "neonverse-aars",
    databaseURL: "https://neonverse-aars-default-rtdb.firebaseio.com"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// --- SCENE & CAMERA ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- LIGHTING ---
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const spot = new THREE.PointLight(0x00f2ff, 100);
scene.add(spot);

// --- FLOOR ---
const grid = new THREE.GridHelper(1000, 100, 0x444444, 0x222222);
scene.add(grid);

// --- PLAYER ---
const player = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({color: 0x00f2ff}));
player.add(body);
scene.add(player);

// --- BUILDING SYSTEM ---
let buildMode = false;
const wallGeo = new THREE.BoxGeometry(5, 5, 0.5);
const ghostMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.4 });
const ghostWall = new THREE.Mesh(wallGeo, ghostMat);
scene.add(ghostWall);
ghostWall.visible = false;

// Snap function
const snap = (val) => Math.round(val / 5) * 5;

// --- INPUTS ---
const keys = {};
window.onkeydown = (e) => {
    keys[e.code] = true;
    if(e.code === 'KeyQ') {
        buildMode = !buildMode;
        ghostWall.visible = buildMode;
        document.getElementById('mode-indicator').style.visibility = buildMode ? 'visible' : 'hidden';
    }
};
window.onkeyup = (e) => keys[e.code] = false;

window.onmousedown = () => {
    if(buildMode) {
        const buildRef = ref(db, 'builds/' + Date.now());
        set(buildRef, {
            x: ghostWall.position.x,
            y: ghostWall.position.y,
            z: ghostWall.position.z,
            ry: ghostWall.rotation.y
        });
    }
};

// --- SYNC BUILDS ---
onChildAdded(ref(db, 'builds'), (data) => {
    const b = data.val();
    const wall = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({color: 0x555555}));
    wall.position.set(b.x, b.y, b.z);
    wall.rotation.y = b.ry;
    scene.add(wall);
});

// --- GAME LOOP ---
function animate() {
    requestAnimationFrame(animate);

    // Movement
    if (keys['KeyW']) player.translateZ(0.2);
    if (keys['KeyS']) player.translateZ(-0.2);
    if (keys['KeyA']) player.rotation.y += 0.05;
    if (keys['KeyD']) player.rotation.y -= 0.05;

    // Build Ghost Placement
    if(buildMode) {
        const forward = new THREE.Vector3(0, 0, 10).applyQuaternion(player.quaternion);
        ghostWall.position.set(
            snap(player.position.x + forward.x),
            2.5,
            snap(player.position.z + forward.z)
        );
        ghostWall.rotation.y = player.rotation.y;
    }

    // Camera follow
    const camPos = new THREE.Vector3(0, 8, -15).applyQuaternion(player.quaternion).add(player.position);
    camera.position.lerp(camPos, 0.1);
    camera.lookAt(player.position);
    spot.position.copy(player.position);

    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
